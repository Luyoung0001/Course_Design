# 数据结构课程设计
## 哈夫曼编/译码器

Course_Design/
├── DecodeOnHaffmanCode/
│   ├── decode.h
│   └── decode.c
├── EncodeOnHaffmanTree/
│   ├── encode.h
│   └── encode.c
├── Helps/
│   └── help.h
├── HuffmanTreeBuild/
│   ├── build.c
│   └── build.h
├── main.c
└── Makefile`



利用哈夫曼编码进行信息通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传数据预先编码，在接收端将传来的数据进行译码（复原）。试为这样的信息收发站写一个哈夫曼的编/译码器。

- 建立哈夫曼树：读入文件(*.souce)，统计文件中字符出现的频度，并以这些字符的频度作为权值，建立哈夫曼树。
- 编码：利用已建立好的哈夫曼树，获得各个字符的哈夫曼编码，并对正文进行编码，然后输出编码结果，并存入文件(*.code)中。
- 译码：利用已建立好的哈夫曼树将文件(x.code)中的代码进行译码，并输出译码结果，并存入文件(x.decode)中。
- 利用位操作，实现文件的压缩与解压。


## 设计思路

### 预期的命令如下:

```c
// 打印出帮助信息,命令行用法,可加参数
haff -h

// 压缩
haff -z 源文件名 -o 压缩文件名

// 解压
haff -u 压缩文件名 -o 解压后文件名
```

### 第一阶段思路
先实现一个简单的,后期功能往上加:
- `haff -z` 实现输出 `*.code`,这是一个文本文件,里面存放着 010101...

- `haff -u` 实现将 `*.code` 恢复成原来的样子


首先,将源文件变成 `*.code`后,这个文件要想在下次操作中恢复,必须包含的信息有:
- Haffman 编码;
- 根据 Haffman 编码将源文件得到的二进制编码.

解压的时候,首先找到 Haffman 字段,然后从文件开始的位置开始恢复文件.


### 第二阶段思路

由于编码后的`*.code` 文件本质上是一个文本文件,其肯定比原文件大很多,那么我们肯定不能将这个文本文件保存起来用于传输.

因此必须将这个文本文件转化成一个二进制文件,就是将文本文件中的 8 个 01 字符当成一个字节写入二进制文件,写入的时候得保证内存对齐,因此你不能保证 0101 文本文件的字符个数恰好是 8 的倍数,因此要在最后一个字符末尾补 0.

比如:01011,我们必须补成 01011000 00000011.为什么要在最后多一个00000011? 这是因为得告诉解码器补了几个 0,如果恰好不需要补,那么也要补 00000000.这样就完美解决了内存对齐问题.

解码的时候,可以设定前 200 个字节为哈夫曼编码信息,从第 200 开始,就是文件编码信息,开始从这里进行解码.这样避免了使用魔数机制开始找开始的地方.


