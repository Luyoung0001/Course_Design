CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
CC=gcc
CFLAGS=-Wall -Wextra -std=c99 -I./DecodeOnHaffmanCode -I./EncodeOnHaffmanTree -I./HuffmanTreeBuild -I./Helps

OBJ=main.o DecodeOnHaffmanCode/decode.o EncodeOnHaffmanTree/encode.o HuffmanTreeBuild/build.o Helps/help.o

main: $(OBJ)
	$(CC) -o main $(OBJ) $(CFLAGS)

main.o: main.c
	$(CC) -c main.c -o main.o $(CFLAGS)

DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }

    return 0;

error:
    return -1;
}#include "build.h"
#include "decode.h"
#include "encode.h"
#include "help.h"
#include <string.h>

int main(int argc, char *argv[]) {
    // Security check
    if (argc < 2) {
        printf("too few arguments.\n");
        goto error;
    }
    if (argc != 2 && argc != 5) {
        printf("Please enter the correct number of parameters.\n");
        goto error;
    }
    // haff -h
    if (argc == 2 && strcmp(argv[1], "-h") == 0) {
        printHelp();
        return 0;
    }

    if (((strcmp(argv[1], "-z") != 0) && (strcmp(argv[1], "-u") != 0)) ||
        strcmp(argv[3], "-o") != 0) {
        printf("Please enter the correct format parameters.\n");
        goto error;
    }

    // prepare for zip and unzip

    // get the being zipped source file, and get the Array
    if (getArray(argv[2]) == -1) {
        printf("being zipped file open failed.\n");
        goto error;
    }

    // when it come to unzip,it needs to load to the leafNodeCodes

    // unzip
    // if (strcmp(argv[1], "-u") == 0) {
    //     // zip -u sourcecode -o targetfile
    //     LeafNodeCode *leafNodeCodes =
    //     loadLeafNodeCode(".haffmancode",&count);
    //
    //     return 0;
    // }
    // unzip
    if (strcmp(argv[1], "-u") == 0) {
        // zip -u sourcecode -o targetfile
        deCode(argv[2], argv[4]);
        return 0;
    }

    // create oder nodes[]
    getPriorityQueue();
    // sort the order nodes[]
    sortPriorityQueue();
    // build the Haffman tree
    Node *root = buildHuffmanTree(priorityQueue, count);
    // print the Haffman tree
    // printHuffmanTree(root);
    // get Haffman Code for each leaf
    LeafNodeCode *leafNodeCodes = getLeafNodeCodes(root);

    // save the leafNodeCodes into a file, when it needs to unzip a file, it
    // must get the leafNodeCodes from the file
    // saveLeafNodeCode(".haffmancode", leafNodeCodes, count);
    // print Byte: Haffman Code
    // for (int i = 0; i < count; i++) {
    //     printf("Character: %c, Huffman Code: %s\n", leafNodeCodes[i].data,
    //            leafNodeCodes[i].code);
    // }
    // zip process
    if (strcmp(argv[1], "-z") == 0) {
        // zip -z sourcefile -o codefile
        if (targetFile(leafNodeCodes, argv[2], argv[4]) == -1) {
            printf("zip error!\n");
            goto error;
        }
    }
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }
    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}
#include "decode.h"

int searchOPreCode(LeafNodeCode *leafNodeCode) {
    if (searchPrecode("0", leafNodeCode) != NULL) {
        return 1;
    }
    if (searchPrecode("00", leafNodeCode) != NULL) {
        return 2;
    }
    if (searchPrecode("000", leafNodeCode) != NULL) {
        return 3;
    }
    if (searchPrecode("0000", leafNodeCode) != NULL) {
        return 4;
    }
    if (searchPrecode("00000", leafNodeCode) != NULL) {
        return 5;
    }
    if (searchPrecode("000000", leafNodeCode) != NULL) {
        return 6;
    }
    if (searchPrecode("0000000", leafNodeCode) != NULL) {
        return 7;
    }
    return 0;
}
// from Haffman Code to a Byte
char *searchPrecode(char *preCode, LeafNodeCode *LeafNodeCodes) {
    for (int i = 0; i < count; i++) {
        if (strcmp(preCode, LeafNodeCodes[i].code) == 0) {
            return &LeafNodeCodes[i].data;
        }
    }
    return NULL;
}
// unzip
void deCode(char *codeFileName, char *decodeFileName) {
    FILE *inFile = fopen(codeFileName, "rb");
    FILE *outFile = fopen(decodeFileName, "wb");
    if (inFile == NULL || outFile == NULL) {
        perror("File open error");
        return;
    }
    // maybe Code
    // char preCode[257];
    // int byte;
    // int tag = -1;
    // char value;
    // while (1) {
    //     memset(preCode, '\0', 257);
    //     int i = -1;
    //     while ((searchPrecode(preCode, LeafNodeCodes)) == NULL) {
    //         byte = fgetc(inFile);
    //         if (byte == EOF) {
    //             tag = 0;
    //             break;
    //         }
    //         preCode[++i] = byte;
    //     }
    //     if (tag == 0) {
    //         break;
    //     }
    //     value = *searchPrecode(preCode, LeafNodeCodes);
    //     if (fwrite(&value, 1, 1, outFile) <= 0) {
    //         perror("unzip error");
    //         return;
    //     }
    // }

    // modified here!

    // check magic number
    uint32_t magicNo = 0;
    fread(&magicNo, sizeof(uint32_t), 1,
          inFile); // Read magic number at the begining of the file first
    if (ntohl(magicNo) != 0xdeadbeef) {
        printf("the decoding file is not a zipped file.\n");
        return;
    }

    // Haffman Code
    int numLeafNodes = 0;
    fread(&numLeafNodes, sizeof(int), 1, inFile); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(inFile);
        return;
    }

    for (int i = 0; i < numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, inFile);
    }

    // the size of file
    long sizeOfFile = 0;
    fread(&sizeOfFile, sizeof(sizeOfFile), 1, inFile);

    // coded file
    uint8_t buffer = 0;  // buffer for 1 Bytes
    char BUFF[16] = {0}; // Code cache
    int len = 0;
    char *value = 0;
    int result = 0;
    int Nwrite = 0; // already written in the file
    printf("\n");
    while (1) {
        int n = fread(&buffer, sizeof(buffer), 1,
                      inFile); // load 1 Byte once a time
        if (n < 1) {
            // end of the file
            break;
        }
        for (int i = 0; i < 8; i++) {
            result = buffer & (1 << (7 - i));
            if (result == 0) {
                BUFF[len++] = '0';
            } else {
                BUFF[len++] = '1';
            }
            value = searchPrecode(BUFF, leafNodeCodes);
            if (value == NULL) {
                continue;
            } else {
                // write in

                if (fwrite(value, 1, 1, outFile) <= 0) {
                    perror("unzip error");
                    return;
                } else {
                    // recover
                    Nwrite++;
                    memset(BUFF, '\0', 16);
                    len = 0;
                }
            }
            if (Nwrite == sizeOfFile) {
                goto finished;
            }
        }
    }
    fclose(inFile);
    fclose(outFile);

finished:
    fclose(inFile);
    fclose(outFile);

    // // reopen the file, modify it
    // outFile = fopen(decodeFileName, "r+b");

    // // erase the last or more bytes in the file
    // int numOfO = buffer; // nums of 0s

    // int lenOf0HaffmanCode = searchOPreCode(leafNodeCodes);
    // if (lenOf0HaffmanCode == 0) {
    //     fclose(outFile);
    //     return;
    // }#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}#include "encode.h"
#include "../HuffmanTreeBuild/build.h"
#define MASKCODE 0x000000ff
#define ZERO 0x00

// get the size of a file
long getFileSize(const char *filename) {
    struct stat st;
    if (stat(filename, &st) == 0) {
        return st.st_size;
    }
    return -1;
}

// search: from a Byte to a Haffman Code
char *searchCode(LeafNodeCode *leafNodeCodes, char data) {
    for (int i = 0; i < count; i++) {
        if (leafNodeCodes[i].data == data) {
            return leafNodeCodes[i].code;
        }
    }
    return 0;
}
// zip
int targetFile(LeafNodeCode *leafNodeCodes, char *fileSourceName,
               char *fileTargetName) {
    FILE *fileSource = fopen(fileSourceName, "rb");
    FILE *fileTarget = fopen(fileTargetName, "wb");
    if (fileSource == NULL || fileTarget == NULL) {
        perror("zip failed!\n");
        return -1;
    }

    // int byte;
    // while ((byte = fgetc(fileSource)) != EOF) {
    //     fprintf(fileTarget, "%s", searchCode(leafNodeCodes, byte));
    // }

    // modify here

    // magic number
    char magicNumber[] = {0xde, 0xad, 0xbe, 0xef}; // magic number: 0xdeadbeef
    fwrite(magicNumber, sizeof(char), sizeof(magicNumber),
           fileTarget); // write magic number to Target file

    // Haffman Code
    fwrite(&numLeafNodes, sizeof(int), 1,
           fileTarget); // Write number of nodes first
    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, fileTarget);
    }

    // the size of the file
    long sizeOfFile = getFileSize(fileSourceName);
    fwrite(&sizeOfFile, sizeof(long), 1, fileTarget);

    // file code
    uint32_t buffer = 0;    // buffer for 4 Bytes
    int lengthOfBUffer = 0; // length of buffer
    int byte;               // Byte from the source file
    int lenOfHaffmanCode = 0;
    while ((byte = fgetc(fileSource)) != EOF) {
        char *haffman_code = searchCode(leafNodeCodes, byte);
        lenOfHaffmanCode = strlen(haffman_code);

        for (int i = 0; i < lenOfHaffmanCode; i++) {
            if (haffman_code[i] == '1') {
                buffer ^= (uint32_t)1;
            } else {
                buffer ^= (uint32_t)0;
            }
            lengthOfBUffer++;

            if (lengthOfBUffer == 8) {
                // get the lowest Byte
                // write the Byte to the file
                unsigned char key = buffer & MASKCODE;
                fprintf(fileTarget, "%c", key);
                lengthOfBUffer -= 8;
            }
            buffer <<= 1;
        }
    }
    // check
    if (lengthOfBUffer == 0) {
        unsigned char key = ZERO;
        fprintf(fileTarget, "%c", key);
    } else {
        // recover
        buffer >>= 1;
        int numsOfBit0 = 8 - lengthOfBUffer;
        buffer <<= numsOfBit0;

        // write last code
        unsigned char key = buffer & MASKCODE;
        fprintf(fileTarget, "%c", key);

        // write the last byte of the file
        // key = numsOfBit0;
        // fprintf(fileTarget, "%c", key);
    }
    fclose(fileSource);
    fclose(fileTarget);
    return 0;
}v#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}


#include "build.h"

int count = 0;              // number of type of bytes
int Array[256] = {0};       // freq of bytes
Node **priorityQueue = {0}; // priorityQueue
int numLeafNodes = 0;       // nums of leafs

// iniy
void init() {
    count = 0;
    for (int i = 0; i < 256; i++) {
        Array[i] = 0;
    }
}

// create a Haffman-Tree node
Node *createNode(char data, int freq) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->data = data;
    newNode->freq = freq;
    newNode->left = newNode->right = NULL;
    return newNode;
}
// where the freq of Bytes lie
int getArray(char *fileName) {
    FILE *file = fopen(fileName, "rb"); // "rb" bini-read mode

    if (file == NULL) {
        perror("File open error");
        return -1;
    }

    unsigned char byte; // must be unsigned
    while (fread(&byte, 1, 1, file) > 0) {
        Array[byte]++;
    }
    fclose(file);
    // counts for the num of Bytes
    for (int i = 0; i < 256; i++) {
        if (Array[i] != 0) {
            count++;
        }
    }
    return count;
}

// create the order queue
void getPriorityQueue() {
    int k = -1;
    priorityQueue = (Node **)malloc(count * sizeof(Node *));
    for (int i = 0; i <= 255; i++) {
        if (Array[i] != 0) {
            k++;
            priorityQueue[k] = createNode(i, Array[i]);
        }
    }
    // test
    // printf("Byte value---the freq of it\n");
    // for (int i = 0; i < 256; i++) {
    //     printf("%d: %d\n", i, Array[i]);
    // }
}
// sort the order queue
void sortPriorityQueue() {
    for (int i = 0; i < count - 1; i++) {
        for (int j = 0; j < count - 1 - i; j++) {
            if (priorityQueue[j]->freq > priorityQueue[j + 1]->freq) {
                Node *temp = priorityQueue[j];
                priorityQueue[j] = priorityQueue[j + 1];
                priorityQueue[j + 1] = temp;
            }
        }
    }
    // test
    // for (int i = 0; i < count; i++) {
    //     printf("%d: %d\n", priorityQueue[i]->data, priorityQueue[i]->freq);
    // }
}

// create empty priorityQueue
PriorityQueue *createPriorityQueue(int capacity) {
    PriorityQueue *queue = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    queue->nodes = (Node **)malloc(sizeof(Node *) * capacity);
    queue->size = 0;
    return queue;
}

// insert node to the priorityQueue
void insert(PriorityQueue *queue, Node *node) {
    int i = queue->size;
    while (i > 0 && node->freq < queue->nodes[(i - 1) / 2]->freq) {
        queue->nodes[i] = queue->nodes[(i - 1) / 2];
        i = (i - 1) / 2;
    }
    queue->nodes[i] = node;
    queue->size++;
}

// pop the smallest freq node
Node *pop(PriorityQueue *queue) {
    if (queue->size <= 0) {
        return NULL;
    }
    Node *minNode = queue->nodes[0];
    queue->size--;

    Node *lastNode = queue->nodes[queue->size];
    int i = 0;
    while (i * 2 + 1 < queue->size) {
        int child = i * 2 + 1;
        if (child + 1 < queue->size &&
            queue->nodes[child + 1]->freq < queue->nodes[child]->freq) {
            child++;
        }
        if (lastNode->freq <= queue->nodes[child]->freq) {
            break;
        }
        queue->nodes[i] = queue->nodes[child];
        i = child;
    }
    queue->nodes[i] = lastNode;

    return minNode;
}

// create Haffman tree
Node *buildHuffmanTree(Node **nodes, int size) {
    if (size <= 0) {
        return NULL;
    }

    // with a PriorityQueue
    PriorityQueue *queue = createPriorityQueue(size);
    for (int i = 0; i < size; i++) {
        insert(queue, nodes[i]);
    }

    // tree building...
    while (queue->size > 1) {
        Node *left = pop(queue);
        Node *right = pop(queue);
        Node *parent = createNode('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        insert(queue, parent);
    }

    Node *root = pop(queue);
    free(queue->nodes);
    free(queue);

    return root;
}
// print the Haffman Tree
void printHuffmanTree(Node *root) {
    if (root == NULL) {
        return;
    }
    // printf("%d - %d\n", root->data, root->freq);
    printHuffmanTree(root->left);
    printHuffmanTree(root->right);
}

// generate Haffman code
void generateLeafNodeCodes(Node *node, char *currentCode,
                           LeafNodeCode *leafNodeCodes, int *index) {
    if (node == NULL) {
        return;
    }
    // go left +0
    char leftCode[256];
    strcpy(leftCode, currentCode);
    strcat(leftCode, "0");
    generateLeafNodeCodes(node->left, leftCode, leafNodeCodes, index);

    // go right +1
    char rightCode[256];
    strcpy(rightCode, currentCode);
    strcat(rightCode, "1");
    generateLeafNodeCodes(node->right, rightCode, leafNodeCodes, index);

    if (node->left == NULL && node->right == NULL) {
        // find the leaf node, save the complete code
        leafNodeCodes[*index].data = node->data;
        strcpy(leafNodeCodes[*index].code, currentCode);
        (*index)++;
    }
}

// craete LeafNodeCode[]
LeafNodeCode *getLeafNodeCodes(Node *root) {
    numLeafNodes = count;

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(numLeafNodes * sizeof(LeafNodeCode));

    int index = 0;
    char currentCode[256] = "";

    // generate leaf code
    generateLeafNodeCodes(root, currentCode, leafNodeCodes, &index);

    return leafNodeCodes;
}

#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
#include "help.h"
// haffman Code char* to Byte
void saveLeafNodeCode(const char *filename, LeafNodeCode *leafNodeCodes,
                      int numLeafNodes) {
    FILE *file = fopen(filename, "wb");
    if (file == NULL) {
        perror("File open error");
        return;
    }

    fwrite(&numLeafNodes, sizeof(int), 1, file); // Write number of nodes first

    for (int i = 0; i < numLeafNodes; ++i) {
        fwrite(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
}
LeafNodeCode *loadLeafNodeCode(const char *filename, int *numLeafNodes) {
    FILE *file = fopen(filename, "rb");
    if (file == NULL) {
        perror("File open error");
        return NULL;
    }

    fread(numLeafNodes, sizeof(int), 1, file); // Read number of nodes first

    LeafNodeCode *leafNodeCodes =
        (LeafNodeCode *)malloc(*numLeafNodes * sizeof(LeafNodeCode));
    if (leafNodeCodes == NULL) {
        perror("Memory allocation error");
        fclose(file);
        return NULL;
    }

    for (int i = 0; i < *numLeafNodes; ++i) {
        fread(&leafNodeCodes[i], sizeof(LeafNodeCode), 1, file);
    }

    fclose(file);
    return leafNodeCodes;
}

void printHelp() {
    printf("\n");
    printf("HAFF(1)                         User Commands                      "
           "  HAFF(1)\n");
    printf("\n");
    printf("NAME\n");
    printf("       haff - compress or decompress files using Huffman coding\n");
    printf("\n");
    printf("SYNOPSIS\n");
    printf("       haff [-h] [-z source_file_name -o compressed_file_name]\n");
    printf("       haff [-h] [-u compressed_file_name -o "
           "decompressed_file_name]\n");
    printf("\n");
    printf("DESCRIPTION\n");
    printf("       haff is a command-line tool to compress or decompress files "
           "using Huffman coding.\n");
    printf("\n");
    printf("OPTIONS\n");
    printf("       -h       Print this help message\n");
    printf("       -z       Compress the source file\n");
    printf("       -u       Decompress the compressed file\n");
    printf("       -o       Specify output file name\n");
    printf("\n");
    printf("EXAMPLES\n");
    printf("       Compress:\n");
    printf("              haff -z source_file_name -o compressed_file_name\n");
    printf("\n");
    printf("       Decompress:\n");
    printf("              haff -u compressed_file_name -o "
           "decompressed_file_name\n");
    printf("\n");
    printf("SEE ALSO\n");
    printf("       haff(2), haff(3)\n");
    printf("\n");
}
v

    // int DeleteNo = (8 + numOfO) / lenOf0HaffmanCode;
    // if (DeleteNo == 0) {
    //     fclose(outFile);
    //     return;
    // }

    // fseek(outFile, (0 - DeleteNo),
    //       SEEK_END); // 将文件指针移动到倒数第一个字节处
    // ftruncate(fileno(outFile), ftell(outFile)); // 截断文件至当前位置

    // fclose(outFile);
}

    return 0;

error:
    return -1;
}
DecodeOnHaffmanCode/decode.o: DecodeOnHaffmanCode/decode.c DecodeOnHaffmanCode/decode.h
	$(CC) -c DecodeOnHaffmanCode/decode.c -o DecodeOnHaffmanCode/decode.o $(CFLAGS)

EncodeOnHaffmanTree/encode.o: EncodeOnHaffmanTree/encode.c EncodeOnHaffmanTree/encode.h
	$(CC) -c EncodeOnHaffmanTree/encode.c -o EncodeOnHaffmanTree/encode.o $(CFLAGS)

HuffmanTreeBuild/build.o: HuffmanTreeBuild/build.c HuffmanTreeBuild/build.h
	$(CC) -c HuffmanTreeBuild/build.c -o HuffmanTreeBuild/build.o $(CFLAGS)

Helps/help.o: Helps/help.c Helps/help.h
	$(CC) -c Helps/help.c -o Helps/help.o $(CFLAGS)

.PHONY: clean

clean:
	rm -f *.o $(OBJ) main
